import org.apache.kafka.clients.consumer.Consumer;
import org.apache.kafka.clients.consumer.OffsetAndTimestamp;
import org.apache.kafka.common.TopicPartition;
import org.springframework.kafka.listener.ConsumerAwareRebalanceListener;
import org.springframework.kafka.listener.ConcurrentMessageListenerContainer;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.support.TopicPartitionOffset;

import java.time.Duration;
import java.util.*;

private ConcurrentMessageListenerContainer<String, Object> getConcurrentMessageListenerContainer(
        ConsumerTopic consumerTopic,
        ConcurrentKafkaListenerContainerFactory<String, Object> factory,
        String groupId,
        Long offset,
        Long timestamp) {

    ConcurrentMessageListenerContainer<String, Object> mlc;

    if (consumerTopic.getPartition() != null) {
        // --- Case: Partition is provided ---
        TopicPartitionOffset topicPartitionOffset = new TopicPartitionOffset(
                consumerTopic.getName(),
                consumerTopic.getPartition()
        );
        mlc = factory.createContainer(topicPartitionOffset);

        // Apply seeking if offset/timestamp provided
        mlc.getContainerProperties().setConsumerRebalanceListener(new ConsumerAwareRebalanceListener() {
            @Override
            public void onPartitionsAssigned(Consumer<?, ?> consumer, Collection<TopicPartition> partitions) {
                partitions.forEach(tp -> {
                    if (tp.partition() == consumerTopic.getPartition()) {
                        if (offset != null) {
                            // Seek to given offset
                            consumer.seek(tp, offset);
                        } else if (timestamp != null) {
                            // Seek to offset resolved by timestamp
                            Map<TopicPartition, Long> tsMap = Map.of(tp, timestamp);
                            Map<TopicPartition, OffsetAndTimestamp> result = consumer.offsetsForTimes(tsMap);
                            OffsetAndTimestamp ot = result.get(tp);
                            if (ot != null) {
                                consumer.seek(tp, ot.offset());
                            }
                        }
                    }
                });
            }
        });

    } else {
        // --- Case: No partition (whole topic or multiple topics) ---
        mlc = factory.createContainer(consumerTopic.getName().split(","));

        mlc.getContainerProperties().setConsumerRebalanceListener(new ConsumerAwareRebalanceListener() {
            @Override
            public void onPartitionsAssigned(Consumer<?, ?> consumer, Collection<TopicPartition> partitions) {
                if (offset != null) {
                    // Seek all partitions to given offset
                    partitions.forEach(tp -> consumer.seek(tp, offset));
                } else if (timestamp != null) {
                    // Seek all partitions to offsets resolved by timestamp
                    Map<TopicPartition, Long> tsMap = new HashMap<>();
                    partitions.forEach(tp -> tsMap.put(tp, timestamp));

                    Map<TopicPartition, OffsetAndTimestamp> result = consumer.offsetsForTimes(tsMap);
                    result.forEach((tp, ot) -> {
                        if (ot != null) {
                            consumer.seek(tp, ot.offset());
                        }
                    });
                }
            }
        });
    }

    // Common container settings
    mlc.getContainerProperties().setGroupId(groupId);
    mlc.setBeanName(groupId);
    mlc.getContainerProperties().setConsumerStartTimeout(Duration.ofSeconds(30));

    return mlc;
}
