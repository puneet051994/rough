private ConcurrentMessageListenerContainer<String, Object> getConcurrentMessageListenerContainer(
        ConsumerTopic consumerTopic,
        ConcurrentKafkaListenerContainerFactory<String, Object> factory,
        String groupId,
        Long offset,
        Long timestamp) {

    ConcurrentMessageListenerContainer<String, Object> mlc;

    if (consumerTopic.getPartition() != null) {
        // --- Case: Partition is provided ---
        if (offset != null) {
            // Start from specific offset
            TopicPartitionOffset topicPartitionOffset = new TopicPartitionOffset(
                    consumerTopic.getName(),
                    consumerTopic.getPartition(),
                    offset
            );
            mlc = factory.createContainer(topicPartitionOffset);

        } else {
            // Default (latest/earliest depending on auto.offset.reset)
            TopicPartitionOffset topicPartitionOffset = new TopicPartitionOffset(
                    consumerTopic.getName(),
                    consumerTopic.getPartition()
            );
            mlc = factory.createContainer(topicPartitionOffset);

            // --- Handle timestamp seeking ---
            if (timestamp != null) {
                mlc.getContainerProperties().setConsumerRebalanceListener(
                        new ConsumerRebalanceListener() {
                            @Override
                            public void onPartitionsAssigned(Collection<TopicPartition> partitions) {
                                partitions.forEach(tp -> {
                                    if (tp.partition() == consumerTopic.getPartition()) {
                                        mlc.getContainerProperties()
                                                .getKafkaConsumer()
                                                .offsetsForTimes(
                                                        Map.of(tp, timestamp)
                                                )
                                                .forEach((assignedTp, offsetAndTs) -> {
                                                    if (offsetAndTs != null) {
                                                        mlc.getContainerProperties()
                                                                .getKafkaConsumer()
                                                                .seek(assignedTp, offsetAndTs.offset());
                                                    }
                                                });
                                    }
                                });
                            }

                            @Override
                            public void onPartitionsRevoked(Collection<TopicPartition> partitions) {
                                // no-op
                            }
                        }
                );
            }
        }
    } else {
        // --- Case: No partition (multiple topics or whole topic) ---
        mlc = factory.createContainer(consumerTopic.getName().split(","));

        if (offset != null) {
            // Seek to offset for each partition after assignment
            mlc.getContainerProperties().setConsumerRebalanceListener(
                    new ConsumerRebalanceListener() {
                        @Override
                        public void onPartitionsAssigned(Collection<TopicPartition> partitions) {
                            partitions.forEach(tp ->
                                    mlc.getContainerProperties().getKafkaConsumer().seek(tp, offset)
                            );
                        }

                        @Override
                        public void onPartitionsRevoked(Collection<TopicPartition> partitions) {
                            // no-op
                        }
                    }
            );
        } else if (timestamp != null) {
            // Seek to timestamp for each partition after assignment
            mlc.getContainerProperties().setConsumerRebalanceListener(
                    new ConsumerRebalanceListener() {
                        @Override
                        public void onPartitionsAssigned(Collection<TopicPartition> partitions) {
                            Map<TopicPartition, Long> timestampsToSearch = new HashMap<>();
                            partitions.forEach(tp -> timestampsToSearch.put(tp, timestamp));

                            Map<TopicPartition, OffsetAndTimestamp> offsets =
                                    mlc.getContainerProperties().getKafkaConsumer().offsetsForTimes(timestampsToSearch);

                            offsets.forEach((tp, ot) -> {
                                if (ot != null) {
                                    mlc.getContainerProperties().getKafkaConsumer().seek(tp, ot.offset());
                                }
                            });
                        }

                        @Override
                        public void onPartitionsRevoked(Collection<TopicPartition> partitions) {
                            // no-op
                        }
                    }
            );
        }
    }

    mlc.getContainerProperties().setGroupId(groupId);
    mlc.setBeanName(groupId);
    return mlc;
}
