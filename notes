    private void prepareConsumers(Map<String, ConcurrentMessageListenerContainer<String, Object>> messageListenerContainerMap, Map<String, Topics> kafkaTopics) {
        if (kafkaTopics.size() <= noOfJourneys) {
            kafkaTopics.forEach((journey, topics) -> {
                if (topics.getSubscribe() != null) {
                    String key = KafkaConfigUtils.getKey(journey, topics.getSubscribe().getName());
                    ConcurrentMessageListenerContainer<String, Object> container = createConsumerContainerPerTopic(journey, topics.getSubscribe());
                    containerMap.put(key, container);
                    assignedPartitionsMap.put(key, new HashSet<>());

                    container.getContainerProperties().setConsumerRebalanceListener(new ConsumerAwareRebalanceListener() {
                        @Override
                        public void onPartitionsAssigned(Consumer<?, ?> consumer, Collection<TopicPartition> partitions) {
                            assignedPartitionsMap.get(key).clear();
                            assignedPartitionsMap.get(key).addAll(partitions);
                            consumerMap.put(key, consumer);
                            log.info("Partitions assigned for {}: {}", key, partitions);
                        }

                        @Override
                        public void onPartitionsRevoked(Collection<TopicPartition> partitions) {
                            assignedPartitionsMap.get(key).removeAll(partitions);
                            consumerMap.remove(key);
                            log.info("Partitions revoked for {}: {}", key, partitions);
                        }
                    });

                    messageListenerContainerMap.put(key, container);
                    container.start();
                }
            });
        } else {
            log.error("Configured journeys exceed allowed limit of {}", noOfJourneys);
        }
    }
